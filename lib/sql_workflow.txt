A brief overview of SQLite in Flutter:

    SQLite is a lightweight relational database that can be used within a Flutter application.
    Flutter includes the sqflite package, which is a Flutter plugin that allows you to use SQLite in your application.
    The sqflite package provides a simple API for performing CRUD (create, read, update, delete) operations on SQLite databases.
    To use sqflite, you first need to create a database. You can do this by calling openDatabase() and passing in the path to the database file.
    Once you have a database, you can create tables by executing SQL statements with execute().
    To insert data into a table, you can use insert() and pass in a map of column values.
    To retrieve data from a table, you can use query(), which returns a list of maps representing the rows in the table.
    To update data in a table, you can use update() and pass in a map of column values and a where clause.
    To delete data from a table, you can use delete() and pass in a where clause.

Here's an example of creating a database, creating a table, inserting data, retrieving data, updating data, and deleting data:

import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

class MyDatabase {
  static final MyDatabase instance = MyDatabase._init();

  static Database? _database;

  MyDatabase._init();

  Future<Database> get database async {
    if (_database != null) return _database!;

    _database = await _initDB('my_database.db');
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
    );
  }

  Future<void> _createDB(Database db, int version) async {
    await db.execute('''
      CREATE TABLE todos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        description TEXT,
        isDone INTEGER
      )
    ''');
  }

  Future<int> insertTodo({
    required String title,
    required String description,
    required bool isDone,
  }) async {
    final db = await instance.database;

    final todo = {
      'title': title,
      'description': description,
      'isDone': isDone ? 1 : 0,
    };

    return await db.insert('todos', todo);
  }

  Future<List<Map<String, dynamic>>> getTodos() async {
    final db = await instance.database;

    return await db.query('todos');
  }

  Future<int> updateTodo({
    required int id,
    required String title,
    required String description,
    required bool isDone,
  }) async {
    final db = await instance.database;

    final todo = {
      'title': title,
      'description': description,
      'isDone': isDone ? 1 : 0,
    };

    return await db.update(
      'todos',
      todo,
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  Future<int> deleteTodo({
    required int id,
  }) async {
    final db = await instance.database;

    return await db.delete(
      'todos',
      where: 'id = ?',
      whereArgs: [id],
    );
  }
}

MODELS AND HELPERS-

In the context of SQL and Flutter, models and helpers are often used together to facilitate database 
operations.

A model is a representation of a database entity, such as a table or a row. It is typically implemented 
as a Dart class that maps to the database schema. The class can have properties that represent columns 
in the table and methods for fetching, inserting, updating, and deleting rows in the table.

A helper, on the other hand, is a utility class that encapsulates database operations. It provides methods 
for opening and closing a database connection, querying the database, and executing SQL statements. 
Helpers are often used to abstract away the details of working with SQLite, making it easier to interact
with the database.

Both models and helpers can be used independently, but they are often used together to provide a more 
organized and maintainable way of interacting with a database. For example, a model might define the 
schema and provide methods for CRUD operations, while a helper might provide the underlying 
implementation of the SQL statements used by the model.

In general, models are used to represent the data in the database, while helpers are used to provide a 
layer of abstraction between the model and the database. By using models and helpers, you can reduce the 
amount of boilerplate code needed to interact with the database, and make your code more modular and 
easier to maintain.


BEST WORKFLOW-

    Design the UI for your app, including any screens that will display data from your local database.

    Create a SQLite database using the sqflite package, and create tables to store your data.

    Create a model class for each table in your database. These classes should have properties for 
    each column in the table, and methods for reading and writing data to the database.

    Create a helper class that will handle all interactions with your database. This class should have 
    methods for creating, reading, updating, and deleting records in your tables.

    In your app's code, create instances of your helper class and use them to read and write data to 
    the database.

    Update your UI to display data from the database, using the models you created earlier.

    Handle user input to create, read, update, or delete records in the database, using your helper 
    class to perform the necessary operations.

    Test your app thoroughly, making sure that all interactions with the database are working as expected.

    Refine your app's UI and functionality as needed, using the feedback from your testing to guide 
    your development.


TAKE AWAY - 

It is a good practice to fully separate the main UI, models, and helpers. This approach makes your code 
more organized and easier to maintain.

The model class should only contain the database schema and methods to convert items into a map and vice 
versa. It should not contain any database-related logic or queries. This makes it easier to update the 
database schema if necessary and also makes the code more modular.

The helper classes should contain all the database-related logic and queries. This includes creating the
database, creating tables, inserting, updating, and deleting items. It is also responsible for opening and 
closing the database connection. By keeping all the database logic in one place, it is easier to make 
changes and debug issues.

Regarding UI, it is best to separate the UI logic from the database logic. This means that you should 
create a separate class to handle the UI and another class to handle the database. The UI class should 
be responsible for displaying the data to the user and receiving input from the user. The database class 
should be responsible for managing the database and providing data to the UI class.

Separating these components makes it easier to maintain and update the code. It also allows you to 
reuse code more easily in other parts of your app or in other apps.

